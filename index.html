<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL Ultimate Draft Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh; padding: 15px; line-height: 1.4; max-width: 1600px; margin: 0 auto; /* Increased max-width */
        }
        .header { text-align: center; margin-bottom: 20px; background: white; padding: 15px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; font-size: 1.8em; margin-bottom: 8px; font-weight: 700; }
        .subtitle { color: #7f8c8d; font-size: 1em; font-weight: 500; }
        .legend {
            background: #fff; padding: 12px; border-radius: 8px; text-align: center;
            margin-bottom: 20px; font-size: 0.9em; box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        .legend-item { display: inline-block; margin: 0 10px; }
        .legend-title { font-weight: 600; cursor: help; border-bottom: 1px dotted #2c3e50; }
        .filters { background: white; padding: 15px; margin-bottom: 15px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; align-items: end; }
        .filter-group { display: flex; flex-direction: column; }
        label { font-weight: 600; margin-bottom: 4px; color: #2c3e50; font-size: 0.85em; }
        select, input { padding: 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 12px; transition: all 0.3s ease; }
        select:focus, input:focus { outline: none; border-color: #a1c4fd; box-shadow: 0 0 0 3px rgba(161, 196, 253, 0.2); }
        .controls { display: flex; gap: 10px; margin-bottom: 15px; justify-content: center; flex-wrap: wrap; }
        .control-button {
            background: linear-gradient(135deg, #e2e8f0 0%, #f1f5f9 100%); color: #475569;
            border: 1px solid #cbd5e1; padding: 8px 16px; border-radius: 8px; cursor: pointer;
            font-weight: 600; transition: all 0.3s ease; font-size: 0.85em;
        }
        .control-button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); }
        .control-button.active { background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); color: #333; border-color: #a1c4fd; }
        .table-container { background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 6px 20px rgba(0,0,0,0.1); overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 0.85em; } /* Font size updated */
        th { background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); color: #333; padding: 10px 6px; text-align: center; font-weight: 600; white-space: nowrap; cursor: pointer; user-select: none; transition: all 0.3s ease; position: sticky; top: 0; z-index: 10; }
        th:hover { background: linear-gradient(135deg, #8ab2f2 0%, #a1c4fd 100%); }
        th.sorted { background: linear-gradient(135deg, #8ab2f2 0%, #a1c4fd 100%); }
        td { padding: 8px 6px; border-bottom: 1px solid #f8f9fa; white-space: nowrap; text-align: center; } /* Bold removed */
        tr:hover { background: #f1f5f9; }
        .name-cell { color: #2c3e50; min-width: 100px; text-align:right; }
        .player-name-icon { margin-right: 5px; font-size: 0.9em; }
        .verbal-insights-cell { white-space: normal; font-size: 0.9em; line-height: 1.2; color: #5a6c7d; min-width: 150px; text-align: right;}
        .position-gkp { background-color: #fff3cd !important; }
        .position-def { background-color: #d1ecf1 !important; }
        .position-mid { background-color: #d4edda !important; }
        .position-fwd { background-color: #e9ecef !important; } /* Changed to light grey */
        .xdiff-positive { color: #27ae60; font-weight: 600; }
        .xdiff-negative { color: #e74c3c; font-weight: 600; }
        .sort-indicator { display: inline-block; margin-left: 3px; }
        .bold-cell { font-weight: 700; } /* Class for bolding specific cells */
        .set-piece-yes { color: #27ae60; font-weight: 700; font-size: 1.2em; }
        .set-piece-no { color: #e74c3c; font-weight: 700; font-size: 1.1em; }
        .news-cell { font-size: 0.8em; } /* Smaller font for news */
        .insights-cell { font-size: 0.95em; line-height: 1.3; } /* Larger font for insights */
        .player-injured { color: #e74c3c; font-weight: 600; }
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
        }
        .modal-content {
            background-color: #f8f9fa; margin: 5% auto; padding: 25px; border: none;
            width: 90%; max-width: 1200px; border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s; }
        .close:hover { color: #333; }
        #compareModal h2 { text-align: center; margin-bottom: 20px; color: #343a40; }
        #compareTable { 
            width: 100%; 
            border-collapse: separate; 
            border-spacing: 0 8px;
            margin-top: 15px;
        }
        #compareTable th { 
            background: #e9ecef;
            color: #495057;
            padding: 12px 15px;
            font-size: 1em;
            text-align: center;
            border: none;
        }
        #compareTable th:first-child { text-align: right; border-top-left-radius: 8px; border-bottom-left-radius: 8px;}
        #compareTable th:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px;}
        #compareTable td {
            background: #fff;
            padding: 12px 15px;
            text-align: center;
            font-size: 1.1em;
            border: none;
            border-bottom: 1px solid #f1f3f5;
        }
        #compareTable tr td:first-child { font-weight: 600; color: #495057; text-align: right; border-top-left-radius: 8px; border-bottom-left-radius: 8px;}
        #compareTable tr td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px;}
        .value-best { background-color: #d1f7c4 !important; font-weight: 700; color: #1a5c0a; }
        .value-good { background-color: #e8f9e4 !important; }
        .value-mid { background-color: #fff9db !important; }
        .value-bad { background-color: #ffe8e8 !important; }
        .value-worst { background-color: #ffd6d6 !important; font-weight: normal; color: #8a2a2a;}
        .emoji-legend { background: white; padding: 15px; margin-bottom: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        .emoji-legend-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; text-align: right; font-size: 0.85em;}
        .insights-list { list-style-type: none; padding-right: 0; margin-right: 0; text-align: right; }
        .insights-list li { margin-bottom: 3px; }
    </style>
</head>
<body>
    <div class="container">
    <div class="header">
            <h1>🏆 FPL Ultimate Draft Tool</h1>
            <p class="subtitle">ניתוח חכם | ציון דראפט ייעודי | סינון מתקדם</p>
        </div>
        <div class="legend">
            <p>
                <span class="legend-item"><strong class="legend-title" title="ציון ייעודי המחושב לפי עמדה להערכת שווי בדראפט. מבוסס על מדדים כמו xG, xA, ICT, BPS, שערים נקיים ועוד, עם משקולות שונות לכל עמדה.">ציון דראפט</strong></span>
                <span class="legend-item"><strong class="legend-title" title="ההפרש בין שערים ובישולים בפועל (G+A) לביצוע הצפוי (xG+xA). ערך חיובי (ירוק) = ביצועי יתר (מעל המצופה). ערך שלילי (אדום) = ביצועי חסר (מתחת למצופה).">xDiff</strong></span>
                <span class="legend-item"><strong class="legend-title" title="מדד השפעה, יצירתיות ואיום">ICT</strong></span>
            </p>
    </div>
    <div class="filters">
            <div class="filter-group"><label>🔍 חיפוש שחקן:</label><input type="text" id="searchName" onkeyup="processChange()" placeholder="שם שחקן..."></div>
            <div class="filter-group"><label>⚽ עמדה:</label><select id="positionFilter" onchange="processChange()"><option value="">כל העמדות</option><option value="GKP">🥅 שוערים</option><option value="DEF">🛡️ מגנים</option><option value="MID">⚽ קשרים</option><option value="FWD">🎯 חלוצים</option></select></div>
            <div class="filter-group"><label>🏟️ קבוצה:</label><select id="teamFilter" onchange="processChange()"><option value="">כל הקבוצות</option></select></div>
            <div class="filter-group"><label>💰 מחיר טווח:</label><input type="text" id="priceRange" onkeyup="processChange()" placeholder="4.0-15.0"></div>
            <div class="filter-group"><label>🏆 נקודות מינימום:</label><input type="number" id="minPoints" onkeyup="processChange()" placeholder="0"></div>
            <div class="filter-group"><label>🎯 טווח xDiff:</label><select id="xDiffFilter" onchange="processChange()"><option value="">כל הטווח</option><option value="positive">חיובי (ביצועי יתר)</option><option value="negative">שלילי (ביצועי חסר)</option></select></div>
            <div class="filter-group"><label>הצג:</label><select id="showEntries" onchange="processChange()"><option value="50">50</option><option value="100">100</option><option value="200">200</option><option value="all" selected>הכל</option></select></div>
        </div>
    <div class="controls">
        <button class="control-button active" onclick="showAllPlayers(this)">כל השחקנים</button>
        <button class="control-button" id="compareBtn" onclick="compareSelectedPlayers()">השווה שחקנים נבחרים</button>
        <button class="control-button" data-filter-name="set_pieces" onclick="quickFilter(this, 'set_pieces')" title="מציג שחקנים שלוקחים פנדלים, קרנות או בעיטות חופשיות, על בסיס הנתונים שזוהו. ממוין לפי ציון דראפט.">🎯 בועטי מצבים נייחים</button>
        <button class="control-button" data-filter-name="attacking_defenders" onclick="quickFilter(this, 'attacking_defenders')" title="מציג שחקני הגנה עם נתוני xGI/90 גבוהים, ששיחקו מעל 300 דקות. המיון הוא לפי ציון דראפט.">🛡️ מגנים תוקפים</button>
        <button class="control-button" data-filter-name="high_ownership" onclick="quickFilter(this, 'high_ownership')" title="מציג שחקנים עם אחוז החזקה מעל 10%. ממוין לפי אחוז החזקה.">📈 שחקנים פופולריים</button>
        <button class="control-button" data-filter-name="overperformers" onclick="quickFilter(this, 'overperformers')" title="מציג שחקנים ששיחקו מעל 300 דקות וה-xDiff שלהם גבוה מ-2.5. המיון הוא לפי ציון דראפט.">📈 ביצועי יתר</button>
        <button class="control-button" data-filter-name="differentials" onclick="quickFilter(this, 'differentials')" title="מציג שחקנים עם אחוז החזקה נמוך מ-5%. המיון הוא לפי ציון דראפט.">💎 מציאות (עד 5%)</button>
        <button class="control-button" data-filter-name="newcomers" onclick="quickFilter(this, 'newcomers')" title="מציג שחקנים ללא דקות משחק בעונה שעברה. המיון הוא לפי ציון 'הייפ' המבוסס על מחיר ואחוז החזקה.">🌟 שחקנים חדשים</button>
        <button class="control-button" onclick="exportToCsv()">📁 יצוא CSV</button>
    </div>

    <div class="emoji-legend">
        <strong>מקרא אייקונים:</strong>
        <div class="emoji-legend-grid">
            <div><span>🎯</span> - בועט פנדלים</div>
            <div><span>⚽</span> - לוקח קרנות</div>
            <div><span>👟</span> - בועט חופשיות</div>
            <div><span>💎</span> - דיפרנציאל (&lt;5% החזקה)</div>
            <div><span>💰</span> - תמורה למחיר (Value)</div>
            <div><span>🌟</span> - שחקן חדש/ללא דקות</div>
            <div><span>📉</span> - ביצועי חסר (xDiff שלילי)</div>
            <div><span>📈</span> - ביצועי יתר (xDiff חיובי)</div>
        </div>
    </div>
    
    <div class="table-container">
        <table id="playersTable">
            <thead>
                <tr>
                    <th onclick="sortTable(0)">דירוג<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(1)">שחקן<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(2)">ציון דראפט<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(3)">קבוצה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(4)">עמדה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(5)">מחיר<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(6)">נקודות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(7)">נק'/משחק<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(8)">% בחירה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(9)">שער+בישול<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(10)">xG+xA<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(11)">דקות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(12)">xDiff<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(13)">ICT<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(14)">בונוס<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(15)">רשת נקייה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(16)">פנדלים<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(17)">קרנות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(18)">חופשיות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(19)">תובנות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(20)">חדשות<span class="sort-indicator"></span></th>
                    <th>בחר</th>
                </tr>
            </thead>
            <tbody id="playersTableBody"></tbody>
        </table>
    </div>

    <div id="compareModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>השוואת שחקנים</h2>
            <div class="table-container">
                <table id="compareTable"></table>
            </div>
        </div>
    </div>

    </div>
    <script>
        let allPlayersData = [];
        let teamsData = {};
        let displayedData = [];
        let sortColumn = 2; // Default sort by Draft Score
        let sortDirection = 'desc';
        let activeQuickFilterName = null;
        let selectedForComparison = new Set();
        
        document.addEventListener('DOMContentLoaded', () => {
            fetchAndProcessData();
            setupEventListeners();
        });

        async function fetchAndProcessData() {
            try {
                const response = await fetch('FPL_Bootstrap_static.json');
                if (!response.ok) throw new Error(`Failed to fetch JSON: ${response.statusText}`);
                
                const data = await response.json();
                const setPieceTakers = getHardcodedSetPieceTakers();
                
                teamsData = data.teams.reduce((acc, team) => {
                    acc[team.id] = team.name;
                    return acc;
                }, {});
                const teamNameToId = {};
                data.teams.forEach(team => { teamNameToId[team.name] = team.id; });

                const existingPlayerNames = new Set(data.elements.map(p => p.web_name.toLowerCase()));
                const newPlayers = [];

                const teamNameMapping = {
                    "Leeds": "Leeds United", "Man City": "Manchester City", "Man Utd": "Manchester United",
                    "Newcastle": "Newcastle United", "Nott'm Forest": "Nottingham Forest", "Spurs": "Tottenham Hotspur",
                    "West Ham": "West Ham United", "Wolves": "Wolverhampton Wanderers"
                };

                for (const teamName in setPieceTakers) {
                    const fplTeamName = teamNameMapping[teamName] || teamName;
                    const teamId = teamNameToId[fplTeamName];
                    if (!teamId) {
                        console.warn(`Could not find a team ID for: ${teamName}`);
                        continue;
                    }

                    const takers = setPieceTakers[teamName];
                    const allTakersInTeam = [...new Set([...takers.penalties, ...takers.corners, ...takers.freekicks])];

                    for (const takerName of allTakersInTeam) {
                        if (!takerName || existingPlayerNames.has(takerName.toLowerCase())) {
                            continue;
                        }

                        const rawNewPlayer = {
                            id: 9000 + newPlayers.length, web_name: takerName, first_name: takerName.split(' ')[0],
                            second_name: takerName.split(' ').slice(1).join(' ') || takerName.split(' ')[0],
                            team: teamId, element_type: 3, now_cost: 75, total_points: 0, points_per_game: '0.0',
                            form: '0.0', minutes: 0, goals_scored: 0, assists: 0, clean_sheets: 0, goals_conceded: 0,
                            own_goals: 0, penalties_saved: 0, penalties_missed: 0, yellow_cards: 0, red_cards: 0,
                            saves: 0, bonus: 0, bps: 0, influence: '0.0', creativity: '0.0', threat: '0.0',
                            ict_index: '0.0', starts: 0, expected_goals: '0.00', expected_assists: '0.00',
                            expected_goal_involvements: '0.00', expected_goals_conceded: '0.00',
                            selected_by_percent: '1.0', news: 'שחקן חדש (סימולציה)', chance_of_playing_next_round: 100
                        };
                        newPlayers.push(rawNewPlayer);
                        existingPlayerNames.add(takerName.toLowerCase());
                    }
                }

                const combinedPlayers = [...data.elements, ...newPlayers];
                allPlayersData = preprocessPlayerData(combinedPlayers, setPieceTakers);
                
                populateTeamFilter();
                processChange(); // Initial render with default sort
            } catch (error) {
                console.error('Error fetching or processing data:', error);
                document.getElementById('playersTableBody').innerHTML = '<tr><td colspan="20">Error loading data. Please try again.</td></tr>';
            }
        }
        
        function getHardcodedSetPieceTakers() {
            // Data parsed from the latest SetPieceTakerSS.csv and mapped to exact FPL web_names
            // NOTE: Only first penalty taker is used. First 2 for others.
            return {
                "Arsenal": { "penalties": ["Saka"], "freekicks": ["Ødegaard", "Rice"], "corners": ["Rice", "Saka"] },
                "Aston Villa": { "penalties": ["Watkins"], "freekicks": ["Digne", "Bailey"], "corners": ["Tielemans", "Digne"] },
                "Bournemouth": { "penalties": ["Kluivert"], "freekicks": ["Tavernier", "Kluivert"], "corners": ["Tavernier", "Kluivert"] },
                "Brentford": { "penalties": ["Wissa"], "freekicks": ["Damsgaard", "Lewis-Potter"], "corners": ["Damsgaard", "Jensen"] },
                "Brighton": { "penalties": ["Welbeck"], "freekicks": ["Welbeck", "O'Riley"], "corners": ["Ayari", "O'Riley"] },
                "Burnley": { "penalties": ["Brownhill"], "freekicks": ["Anthony", "Brownhill"], "corners": ["Anthony", "Gudmundsson"] },
                "Chelsea": { "penalties": ["Palmer"], "freekicks": ["Palmer", "James"], "corners": ["Gallagher", "Chilwell"] },
                "Crystal Palace": { "penalties": ["Eze"], "freekicks": ["Eze", "Olise"], "corners": ["Eze", "Hughes"] },
                "Everton": { "penalties": ["McNeil"], "freekicks": ["Garner"], "corners": ["McNeil", "Garner"] },
                "Fulham": { "penalties": ["Jiménez"], "freekicks": ["Andreas", "Jiménez"], "corners": ["Andreas", "Lukic"] },
                "Leeds": { "penalties": ["Struijk"], "freekicks": ["Gruev", "Aaronson"], "corners": ["James", "Gruev"] },
                "Liverpool": { "penalties": ["M.Salah"], "freekicks": ["Szoboszlai", "Mac Allister"], "corners": ["Mac Allister", "Wirtz"] },
                "Man City": { "penalties": ["Haaland"], "freekicks": ["De Bruyne", "Foden"], "corners": ["Foden", "De Bruyne"] },
                "Man Utd": { "penalties": ["B.Fernandes"], "freekicks": ["B.Fernandes", "Cunha"], "corners": ["B.Fernandes", "Mbeumo"] },
                "Newcastle": { "penalties": ["Isak"], "freekicks": ["Trippier", "Schär"], "corners": ["Trippier", "Elanga"] }, 
                "Nott'm Forest": { "penalties": ["Wood"], "freekicks": ["Gibbs-White", "Murillo"], "corners": ["Anderson", "Gibbs-White"] },
                "Sunderland": { "penalties": ["Rigg"], "freekicks": ["Roberts", "Pritchard"], "corners": ["Roberts", "Pritchard"] },
                "Spurs": { "penalties": ["Solanke"], "freekicks": ["Pedro Porro", "Maddison"], "corners": ["Maddison", "Pedro Porro"] },
                "West Ham": { "penalties": ["L.Paquetá"], "freekicks": ["Ward-Prowse", "L.Paquetá"], "corners": ["Bowen", "Ward-Prowse"] },
                "Wolves": { "penalties": ["Strand Larsen"], "freekicks": ["J.Arias", "Sarabia"], "corners": ["Bellegarde", "Nouri"] }
            };
        }

        function getPositionName(elementTypeId) {
            switch (elementTypeId) {
                case 1: return 'GKP';
                case 2: return 'DEF';
                case 3: return 'MID';
                case 4: return 'FWD';
                default: return 'Unknown';
            }
        }
        
        function preprocessPlayerData(players, setPieceTakers) {
            const positions = { 1: [], 2: [], 3: [], 4: [] };
            
            // Create a flat list of main penalty takers for a direct and reliable check
            const mainPenaltyTakers = Object.values(setPieceTakers)
                .map(takers => takers.penalties[0]) // Get the first penalty taker from each team's list
                .filter(name => name) // Filter out any undefined/empty names
                .map(name => name.toLowerCase()); // Convert all to lower case for matching
            
            players.forEach(p => {
                if (p.element_type in positions) {
                    positions[p.element_type].push(p.now_cost / 10);
                }
            });

            const priceTiers = {};
            for (const posId in positions) {
                const prices = positions[posId].sort((a, b) => a - b);
                priceTiers[posId] = {
                    p95: getPercentile(prices, 95),
                    p80: getPercentile(prices, 80),
                    p50: getPercentile(prices, 50)
                };
            }

            return players.map(p => {
                const minutes = p.minutes || 0;
                const gi = (p.goals_scored || 0) + (p.assists || 0);
                const xgi = parseFloat(p.expected_goal_involvements) || 0;

                p.xG_per90 = minutes > 0 ? (parseFloat(p.expected_goals) / minutes) * 90 : 0;
                p.xA_per90 = minutes > 0 ? (parseFloat(p.expected_assists) / minutes) * 90 : 0;
                p.xGI_per90 = minutes > 0 ? (parseFloat(p.expected_goal_involvements) / minutes) * 90 : 0;
                p.xGC_per90 = minutes > 0 ? (parseFloat(p.expected_goals_conceded) / minutes) * 90 : 0;
                p.ict_per_90 = minutes > 0 ? (parseFloat(p.ict_index) / minutes) * 90 : 0;

                p.xDiff = gi - xgi;
                p.now_cost = p.now_cost / 10;
                p.team_name = teamsData[p.team];
                p.position_name = getPositionName(p.element_type);
                
                const normalizedPlayerName = p.web_name.toLowerCase();

                // --- NEW, MORE RELIABLE LOGIC ---
                // 1. Check against the simple, flat list of main penalty takers
                p.takes_penalties = mainPenaltyTakers.includes(normalizedPlayerName);
                
                // 2. For corners and free kicks, check if the player is listed for ANY team (to handle transfers)
                p.takes_corners = false;
                p.takes_free_kicks = false;
                for (const teamName in setPieceTakers) {
                    const takers = setPieceTakers[teamName];
                    if (takers.corners.some(name => normalizedPlayerName === name.toLowerCase())) {
                        p.takes_corners = true;
                    }
                    if (takers.freekicks.some(name => normalizedPlayerName === name.toLowerCase())) {
                        p.takes_free_kicks = true;
                    }
                }
                
                const tiers = priceTiers[p.element_type];
                if (p.now_cost >= tiers.p95) p.price_tier = 'Elite';
                else if (p.now_cost >= tiers.p80) p.price_tier = 'Premium';
                else if (p.now_cost >= tiers.p50) p.price_tier = 'Mid-range';
                else p.price_tier = 'Budget';

                // Points Per Game
                p.points_per_game = p.minutes > 0 ? ((p.total_points / p.minutes) * 90).toFixed(2) : '0.00';

                // DRAFT SCORE LOGIC
                let draft_score = 0;
                if (minutes === 0) { // Newcomer: Hype Score
                    draft_score = (p.now_cost * 4) + (parseFloat(p.selected_by_percent) * 1.5);
                } else if (minutes > 0 && minutes < 90) { // Low minutes player: Conservative score
                    draft_score = p.total_points * 1.5;
                } else { // Established players
                    draft_score = (parseFloat(p.points_per_game) * 10) + 
                                  (p.ict_per_90 * 2) + 
                                  (p.xGI_per90 * 20);
                    draft_score += (parseFloat(p.selected_by_percent) / 5); // Ownership boost
                }
                p.draft_score = Math.max(0, draft_score); // Ensure no negative scores


                return p;
            });
        }

        function getPercentile(sortedArr, percentile) {
            if (!sortedArr.length) return 0;
            const index = (percentile / 100) * (sortedArr.length - 1);
            const floor = Math.floor(index);
            const ceil = Math.ceil(index);
            if (floor === ceil) return sortedArr[floor];
            const d0 = sortedArr[floor] * (ceil - index);
            const d1 = sortedArr[ceil] * (index - floor);
            return d0 + d1;
        }

        function setupEventListeners() {
            document.getElementById('searchName').addEventListener('keyup', processChange);
            document.getElementById('positionFilter').addEventListener('change', processChange);
            document.getElementById('teamFilter').addEventListener('change', processChange);
            document.getElementById('priceRange').addEventListener('keyup', processChange);
            document.getElementById('minPoints').addEventListener('keyup', processChange);
            document.getElementById('xDiffFilter').addEventListener('change', processChange);
            document.getElementById('showEntries').addEventListener('change', processChange);
        }

        function populateTeamFilter() {
            const teamFilter = document.getElementById('teamFilter');
            const uniqueTeams = [...new Set(allPlayersData.map(p => p.team_name))].sort();
            uniqueTeams.forEach(team => teamFilter.add(new Option(team, team)));
        }

        function renderTable() {
            const tbody = document.getElementById('playersTableBody');
            const showCount = document.getElementById('showEntries').value;
            const dataToRender = showCount === 'all' ? displayedData : displayedData.slice(0, parseInt(showCount));
            tbody.innerHTML = '';
            
            dataToRender.forEach((p, index) => {
                const row = tbody.insertRow();
                row.className = `position-${p.position_name.toLowerCase()}`;
                
                const xDiffClass = p.xDiff > 0 ? 'xdiff-positive' : p.xDiff < 0 ? 'xdiff-negative' : '';
                
                const isInjured = p.news && (p.news.toLowerCase().includes('injury') || p.news.toLowerCase().includes('doubt') || p.news.toLowerCase().includes('out'));
                const injuredClass = isInjured ? 'player-injured' : '';

                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td class="name-cell ${injuredClass}">${generatePlayerIcons(p)}${p.web_name}</td>
                    <td class="bold-cell">${p.draft_score.toFixed(1)}</td>
                    <td>${p.team_name}</td>
                    <td>${p.position_name}</td>
                    <td>£${p.now_cost.toFixed(1)}</td>
                    <td class="bold-cell">${p.total_points}</td>
                    <td>${p.points_per_game}</td>
                    <td>${p.selected_by_percent}%</td>
                    <td>${(p.goals_scored || 0) + (p.assists || 0)}</td>
                    <td>${p.expected_goal_involvements}</td>
                    <td>${p.minutes}</td>
                    <td class="${xDiffClass}">${p.xDiff.toFixed(2)}</td>
                    <td>${p.ict_index}</td>
                    <td>${p.bonus}</td>
                    <td>${p.clean_sheets}</td>
                    <td><span class="${p.takes_penalties ? 'set-piece-yes' : 'set-piece-no'}">${p.takes_penalties ? '✔' : '❌'}</span></td>
                    <td><span class="${p.takes_corners ? 'set-piece-yes' : 'set-piece-no'}">${p.takes_corners ? '✔' : '❌'}</span></td>
                    <td><span class="${p.takes_free_kicks ? 'set-piece-yes' : 'set-piece-no'}">${p.takes_free_kicks ? '✔' : '❌'}</span></td>
                    <td class="insights-cell">${generateVerbalInsights(p)}</td>
                    <td class="news-cell" title="${p.news || ''}">${p.news ? p.news.substring(0, 15) + (p.news.length > 15 ? '...' : '') : ''}</td>
                    <td><input type="checkbox" class="compare-checkbox" data-player-id="${p.id}" onchange="toggleCompare(${p.id})"></td>
                `;
            });
        }

        function generatePlayerIcons(p) {
            const icons = [];
            if (p.takes_penalties) icons.push(`<span class='player-name-icon'>🎯</span>`);
            if (p.takes_corners) icons.push(`<span class='player-name-icon'>⚽</span>`);
            if (p.takes_free_kicks) icons.push(`<span class='player-name-icon'>👟</span>`);
            if (parseFloat(p.selected_by_percent) < 5) icons.push(`<span class='player-name-icon'>💎</span>`);
            if (p.price_tier === 'Budget' && p.points_per_game > 3.5) icons.push(`<span class='player-name-icon'>💰</span>`);
            if (p.minutes === 0) icons.push(`<span class='player-name-icon'>🌟</span>`);
            return icons.join("");
        }
        
        function generateVerbalInsights(p) {
            const insights = [];
            if (p.takes_penalties) insights.push("<li>בועט פנדלים</li>");
            if (p.takes_corners) insights.push("<li>לוקח קרנות</li>");
            if (p.takes_free_kicks) insights.push("<li>בועט חופשיות</li>");
            if (parseFloat(p.selected_by_percent) < 5 && p.minutes > 0) insights.push(`<li>דיפרנציאל (${p.selected_by_percent}%)</li>`);
            if (p.price_tier === 'Budget' && p.points_per_game > 3.5) insights.push("<li>תמורה למחיר (Value)</li>");
            if (p.minutes === 0) insights.push("<li>שחקן חדש/ללא דקות</li>");
            if (p.xDiff < -0.5) insights.push(`<li>ביצועי חסר (xDiff: ${p.xDiff.toFixed(2)})</li>`);
            if (p.xDiff > 0.5) insights.push(`<li>ביצועי יתר (xDiff: ${p.xDiff.toFixed(2)})</li>`);
            
            if (insights.length > 0) {
                return `<ul class="insights-list">${insights.join('')}</ul>`;
            }
            return '';
        }
        
        function processChange() {
            const searchName = document.getElementById('searchName').value.toLowerCase();
            const position = document.getElementById('positionFilter').value;
            const team = document.getElementById('teamFilter').value;
            const priceRange = document.getElementById('priceRange').value;
            const minPoints = parseInt(document.getElementById('minPoints').value, 10) || 0;
            const xDiffFilter = document.getElementById('xDiffFilter').value;
            
            let [minPrice, maxPrice] = [0, 99];
            if (priceRange && priceRange.includes('-')) {
                [minPrice, maxPrice] = priceRange.split('-').map(p => parseFloat(p.trim())).filter(v => !isNaN(v));
                if (typeof maxPrice === 'undefined') maxPrice = 99;
            }
            
            let filtered = allPlayersData.filter(p => {
                const xDiffMatch = !xDiffFilter || (xDiffFilter === 'positive' && p.xDiff > 0) || (xDiffFilter === 'negative' && p.xDiff < 0);
                return p.web_name.toLowerCase().includes(searchName) && 
                       (!position || p.position_name === position) && 
                       (!team || p.team_name === team) && 
                       p.now_cost >= (minPrice || 0) && p.now_cost <= (maxPrice || 99) && 
                       p.total_points >= minPoints && 
                       xDiffMatch;
            });
            
            if (activeQuickFilterName) {
                filtered = applyQuickFilter(filtered, activeQuickFilterName);
            }

            sortAndDisplay(filtered);
        }
        
        function applyQuickFilter(data, filterName) {
            switch(filterName) {
                case 'set_pieces':
                    return data.filter(p => p.takes_penalties || p.takes_corners || p.takes_free_kicks);
                case 'attacking_defenders':
                    return data.filter(p => p.position_name === 'DEF' && p.minutes > 300);
                case 'high_ownership':
                    return data.filter(p => parseFloat(p.selected_by_percent) >= 10);
                case 'overperformers':
                    return data.filter(p => p.minutes > 300 && p.xDiff > 2.5);
                case 'differentials':
                    return data.filter(p => parseFloat(p.selected_by_percent) < 5);
                case 'newcomers':
                    return data.filter(p => p.minutes === 0);
                default:
                    return data;
            }
        }

        function sortAndDisplay(data) {
            const fields = ['rank', 'web_name', 'draft_score', 'team_name', 'position_name', 'now_cost', 'total_points', 'points_per_game', 'selected_by_percent', 'goals_scored', 'expected_goal_involvements', 'minutes', 'xDiff', 'ict_index', 'bonus', 'clean_sheets', 'takes_penalties', 'takes_corners', 'takes_free_kicks', 'verbal_insights', 'news'];
            const sortField = fields[sortColumn];
            const numericFields = ['draft_score', 'now_cost', 'total_points', 'points_per_game', 'selected_by_percent', 'minutes', 'xDiff', 'ict_index', 'bonus', 'clean_sheets'];

            data.sort((a, b) => {
                let valA = a[sortField];
                let valB = b[sortField];

                if (sortField === 'verbal_insights') {
                    valA = generateVerbalInsights(a);
                    valB = generateVerbalInsights(b);
                } else if (sortField === 'goals_scored') { // Special handling for G+A
                    valA = (a.goals_scored || 0) + (a.assists || 0);
                    valB = (b.goals_scored || 0) + (b.assists || 0);
                }
                
                if (numericFields.includes(sortField)) {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }

                if (typeof valA === 'string') {
                    return sortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return sortDirection === 'asc' ? (valA || 0) - (valB || 0) : (valB || 0) - (valA || 0);
            });

            displayedData = data;
            renderTable();
        }

        function sortTable(columnIndex) {
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = columnIndex;
                sortDirection = 'desc';
            }
            
            document.querySelectorAll('th').forEach((th, i) => {
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) { // Add this check
                    indicator.textContent = '';
                    if (i === columnIndex) {
                        th.classList.add('sorted');
                        indicator.textContent = sortDirection === 'desc' ? '▼' : '▲'; 
                    } else {
                        th.classList.remove('sorted');
                    }
                }
            });
            processChange();
        }
        
        function toggleCompare(playerId) {
            if (selectedForComparison.has(playerId)) {
                selectedForComparison.delete(playerId);
            } else {
                selectedForComparison.add(playerId);
            }
        }

        function setActiveButton(button) {
            document.querySelectorAll('.control-button').forEach(btn => btn.classList.remove('active'));
            if (button) button.classList.add('active');
        }

        function showAllPlayers(btn) {
            setActiveButton(btn);
            activeQuickFilterName = null;
            document.querySelectorAll('.filters input, .filters select').forEach(el => {
                if (el.id !== 'showEntries' && el.id !== 'minPoints') el.value = '';
            });
            document.getElementById('minPoints').value = '0';
            processChange();
        }
        
        function quickFilter(btn, filterName) {
            const wasActive = btn.classList.contains('active');
            
            if (wasActive) {
                activeQuickFilterName = null;
                setActiveButton(document.querySelector('.control-button[onclick^="showAllPlayers"]'));
            } else {
                activeQuickFilterName = filterName;
                setActiveButton(btn);
            }
            
            // Special sort for high ownership, default for all others
            if (filterName === 'high_ownership') {
                sortTable(8, 'desc'); // Sort by selected_by_percent
            } else {
                sortTable(2, 'desc'); // Default to draft score
            }
            
            processChange();
        }

        function exportToCsv() {
            const headers = ['Rank','Player','Draft Score','Team','Position','Price','Points','PPG','Selected %','G+A','xG+xA','Minutes','xDiff','ICT','Bonus','Clean Sheets','Penalties','Corners','Free Kicks','Insights','News'];
            let csvContent = headers.join(',') + '\n';
            displayedData.forEach((p, i) => {
                const insightsText = generateVerbalInsights(p).replace(/<li>/g, '').replace(/<\/li>/g, ', ').replace(/<ul class="insights-list">/g, '').replace(/<\/ul>/g, '');
                const row = [
                    i + 1,
                    p.web_name.replace(/,/g, ''),
                    p.draft_score.toFixed(1),
                    p.team_name,
                    p.position_name,
                    p.now_cost,
                    p.total_points,
                    p.points_per_game,
                    p.selected_by_percent,
                    (p.goals_scored || 0) + (p.assists || 0),
                    p.expected_goal_involvements,
                    p.minutes,
                    p.xDiff.toFixed(2),
                    p.ict_index,
                    p.bonus,
                    p.clean_sheets,
                    p.takes_penalties ? 'Yes' : 'No',
                    p.takes_corners ? 'Yes' : 'No',
                    p.takes_free_kicks ? 'Yes' : 'No',
                    `"${insightsText}"`,
                    `"${p.news || ''}"`
                ];
                csvContent += row.join(',') + '\n';
            });
            const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.setAttribute("href", URL.createObjectURL(blob));
            link.setAttribute("download", "fpl_draft_data.csv");
            link.click();
        }
        
        function compareSelectedPlayers() {
            if (selectedForComparison.size < 2) {
                alert('יש לבחור לפחות שני שחקנים להשוואה.');
                return;
            }
            const playersToCompare = allPlayersData.filter(p => selectedForComparison.has(p.id));
            const modal = document.getElementById('compareModal');
            const table = document.getElementById('compareTable');
            table.innerHTML = '';

            const headers = ['Metric', ...playersToCompare.map(p => p.web_name)];
            table.innerHTML = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
            
            const metrics = [
                {key: 'position_name', label: 'עמדה', type: 'string'},
                {key: 'draft_score', label: 'ציון דראפט', type: 'number'},
                {key: 'now_cost', label: 'מחיר', type: 'number', reverse: true},
                {key: 'total_points', label: 'סה"כ נקודות', type: 'number'},
                {key: 'xGI_per90', label: 'xGI/90', type: 'number'},
                {key: 'xGC_per90', label: 'xGC/90', type: 'number', reverse: true},
                {key: 'xDiff', label: 'xDiff', type: 'number'},
                {key: 'ict_per_90', label: 'ICT/90', type: 'number'},
                {key: 'takes_penalties', label: 'בועט פנדלים', type: 'boolean'},
                {key: 'takes_corners', label: 'מרים קרנות', type: 'boolean'},
                {key: 'takes_free_kicks', label: 'בועט חופשיות', type: 'boolean'},
                {key: 'news', label: 'חדשות', type: 'string'}
            ];

            let bodyHtml = '<tbody>';
            metrics.forEach(metric => {
                bodyHtml += `<tr><td><strong>${metric.label}</strong></td>`;
                const metricValues = playersToCompare.map(p => p[metric.key]).filter(v => typeof v === 'number');
                const min = Math.min(...metricValues);
                const max = Math.max(...metricValues);

                playersToCompare.forEach(p => {
                    const value = p[metric.key];
                    let displayValue = value;
                    let colorClass = '';
                    if (metric.type === 'string') {
                        if (metric.key === 'news' && value) {
                            displayValue = `<span title="${value}">${value.substring(0, 15)}...</span>`;
                        } else {
                            displayValue = value || '-';
                        }
                    }
                    else if (metric.type === 'boolean') {
                        displayValue = value ? '✔' : '❌';
                        colorClass = value ? 'value-good' : '';
                    } else if (typeof value === 'number') {
                        displayValue = value.toFixed(2);
                        colorClass = getColorClass(value, min, max, !!metric.reverse);
                    } else {
                        displayValue = value || '-';
                    }
                    bodyHtml += `<td class="${colorClass}">${displayValue}</td>`;
                });
                bodyHtml += '</tr>';
            });
            bodyHtml += '</tbody>';
            table.innerHTML += bodyHtml;

            modal.style.display = 'block';
        }

        function getColorClass(value, min, max, reverse = false) {
            if (typeof value !== 'number' || min === max) return '';
            const normalized = (value - min) / (max - min);
            const effNorm = reverse ? 1 - normalized : normalized;
            if (effNorm > 0.95) return 'value-best';
            if (effNorm > 0.65) return 'value-good';
            if (effNorm > 0.35) return 'value-mid';
            if (effNorm > 0.05) return 'value-bad';
            return 'value-worst';
        }

        function closeModal() {
            document.getElementById('compareModal').style.display = 'none';
        }

    </script>
</body>
</html>
